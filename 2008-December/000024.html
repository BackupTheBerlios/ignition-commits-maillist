<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Ignition-commits] r15 - in trunk: . distribution	distribution/full/misc help/deutsch help/english libs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/ignition-commits/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:ignition-commits%40lists.berlios.de?Subject=Re%3A%20%5BIgnition-commits%5D%20r15%20-%20in%20trunk%3A%20.%20distribution%0A%09distribution/full/misc%20help/deutsch%20help/english%20libs&In-Reply-To=%3C200812142242.mBEMg1J7032658%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000016.html">
   <LINK REL="Next"  HREF="000025.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Ignition-commits] r15 - in trunk: . distribution	distribution/full/misc help/deutsch help/english libs</H1>
    <B>marust at mail.berlios.de</B> 
    <A HREF="mailto:ignition-commits%40lists.berlios.de?Subject=Re%3A%20%5BIgnition-commits%5D%20r15%20-%20in%20trunk%3A%20.%20distribution%0A%09distribution/full/misc%20help/deutsch%20help/english%20libs&In-Reply-To=%3C200812142242.mBEMg1J7032658%40sheep.berlios.de%3E"
       TITLE="[Ignition-commits] r15 - in trunk: . distribution	distribution/full/misc help/deutsch help/english libs">marust at mail.berlios.de
       </A><BR>
    <I>Sun Dec 14 23:42:01 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000016.html">[Ignition-commits] r14 - in trunk: docs misc misc/Masons Icons rexx
</A></li>
        <LI>Next message: <A HREF="000025.html">[Ignition-commits] r15 - in trunk: . distribution distribution/full/misc help/deutsch help/english libs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24">[ date ]</a>
              <a href="thread.html#24">[ thread ]</a>
              <a href="subject.html#24">[ subject ]</a>
              <a href="author.html#24">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: marust
Date: 2008-12-14 23:41:08 +0100 (Sun, 14 Dec 2008)
New Revision: 15
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/ignition?rev=15&amp;view=rev">http://svn.berlios.de/viewcvs/ignition?rev=15&amp;view=rev</A>

Added:
   trunk/locale.c
   trunk/mmakefile.src
   trunk/wdt.h
Modified:
   trunk/
   trunk/History
   trunk/LICENSE
   trunk/Makefile
   trunk/README
   trunk/SCOPTIONS
   trunk/boopsi.c
   trunk/calc.c
   trunk/calc.h
   trunk/cell.c
   trunk/classes.c
   trunk/classes.h
   trunk/clip.c
   trunk/cmd.c
   trunk/color.c
   trunk/database.c
   trunk/debug.c
   trunk/debug.h
   trunk/diagram.c
   trunk/distribution/README
   trunk/distribution/full/misc/ignition-DeInstall
   trunk/distribution/make-full
   trunk/distribution/makefile-full
   trunk/edit.c
   trunk/font.c
   trunk/font.h
   trunk/funcs.h
   trunk/functions.c
   trunk/gadgets.c
   trunk/gadgets.h
   trunk/graphic.c
   trunk/graphic.h
   trunk/handleprefs.c
   trunk/handlewindows.c
   trunk/help/deutsch/ignition.guide
   trunk/help/deutsch/ignition.in.guide
   trunk/help/english/ignition.guide
   trunk/help/english/ignition.in.guide
   trunk/hooks.c
   trunk/ignition.c
   trunk/images.c
   trunk/images.h
   trunk/initwindows.c
   trunk/io.c
   trunk/io.h
   trunk/libs/compatibility.c
   trunk/lock.c
   trunk/menu.c
   trunk/objects.c
   trunk/pointer.c
   trunk/popper.c
   trunk/prefs.c
   trunk/prefs.h
   trunk/prefsgadgets.c
   trunk/prefsio.c
   trunk/printer.c
   trunk/project.c
   trunk/reference.c
   trunk/rexx.c
   trunk/screen.c
   trunk/search.c
   trunk/support.c
   trunk/table.c
   trunk/table.h
   trunk/types.h
   trunk/undo.c
   trunk/version.h
   trunk/windefs.h
   trunk/windows.c
   trunk/windows.h
Log:
* AROS and GCC port of Ignition
* A lot of warnings removed
* Renamed macros NewList, AddHead etc. to MyNewList, MyAddHead etc.
  because of name collision.



Property changes on: trunk
___________________________________________________________________
Name: svn:ignore
   + mmakefile



Property changes on: trunk/History
___________________________________________________________________
Name: svn:keywords
   + Author Date Id Revision
Name: svn:eol-style
   + native


Property changes on: trunk/LICENSE
___________________________________________________________________
Name: svn:keywords
   + Author Date Id Revision
Name: svn:eol-style
   + native


Property changes on: trunk/Makefile
___________________________________________________________________
Name: svn:keywords
   + Author Date Id Revision
Name: svn:eol-style
   + native


Property changes on: trunk/README
___________________________________________________________________
Name: svn:keywords
   + Author Date Id Revision
Name: svn:eol-style
   + native


Property changes on: trunk/SCOPTIONS
___________________________________________________________________
Name: svn:keywords
   + Author Date Id Revision
Name: svn:eol-style
   + native

Modified: trunk/boopsi.c
===================================================================
--- trunk/boopsi.c	2008-12-13 10:00:37 UTC (rev 14)
+++ trunk/boopsi.c	2008-12-14 22:41:08 UTC (rev 15)
@@ -9,6 +9,7 @@
 #include &quot;funcs.h&quot;
 
 #include &lt;graphics/rpattr.h&gt;
+#include &lt;intuition/gadgetclass.h&gt;
 //#include &lt;datatypes/pictureclass.h&gt;
 
 #if !defined(PDTM_WRITEPIXELARRAY)
@@ -36,15 +37,15 @@
 #define IM(o) ((struct Image *)o)
 
 
-extern ULONG PUBLIC RenderHook(reg (a1) struct LVDrawMsg *msg,reg (a2) struct ImageNode *in);
-extern ULONG PUBLIC PopUpHook(reg (a1) struct LVDrawMsg *msg,reg (a2) struct Node *n);
-extern ULONG PUBLIC FormelHook(reg (a1) struct LVDrawMsg *msg,reg (a2) struct Node *n);
-extern ULONG PUBLIC gLinkHook(reg (a1) struct LVDrawMsg *msg,reg (a2) struct gLink *gl);
-extern ULONG PUBLIC LinkHook(reg (a1) struct LVDrawMsg *msg,reg (a2) struct Link *l);
-extern ULONG PUBLIC FormatHook(reg (a1) struct LVDrawMsg *msg,reg (a2) struct Node *n);
-extern ULONG PUBLIC SelectHook(reg (a1) struct LVDrawMsg *msg,reg (a2) struct Node *n);
-extern ULONG PUBLIC ColorHook(reg (a1) struct LVDrawMsg *msg,reg (a2) struct colorPen *cp);
-extern void PUBLIC fillHookFunc(reg (a0) struct Hook *h, reg (a2) struct RastPort *rastp, reg (a1) struct Rectangle *rect);
+extern ULONG PUBLIC RenderHook(REG(a0, struct Hook *h),REG(a2, struct ImageNode *in),REG(a1, struct LVDrawMsg *msg));
+extern ULONG PUBLIC PopUpHook(REG(a0, struct Hook *h),REG(a2, struct Node *n),REG(a1, struct LVDrawMsg *msg));
+extern ULONG PUBLIC FormelHook(REG(a0, struct Hook *h),REG(a2, struct Node *n),REG(a1, struct LVDrawMsg *msg));
+extern ULONG PUBLIC gLinkHook(REG(a0, struct Hook *h),REG(a2, struct gLink *gl),REG(a1, struct LVDrawMsg *msg));
+extern ULONG PUBLIC LinkHook(REG(a0, struct Hook *h),REG(a2, struct Link *l),REG(a1, struct LVDrawMsg *msg));
+extern ULONG PUBLIC FormatHook(REG(a0, struct Hook *h),REG(a2, struct Node *n),REG(a1, struct LVDrawMsg *msg));
+extern ULONG PUBLIC SelectHook(REG(a0, struct Hook *h),REG(a2, struct Node *n),REG(a1, struct LVDrawMsg *msg));
+extern ULONG PUBLIC ColorHook(REG(a0, struct Hook *h),REG(a2, struct colorPen *cp),REG(a1, struct LVDrawMsg *msg));
+extern void PUBLIC fillHookFunc(REG(a0, struct Hook *h), REG(a2, struct RastPort *rastp), REG(a1, struct Rectangle *rect));
 
 
 /********************************** Page-Gadget **********************************/
@@ -81,22 +82,22 @@
 }
 
 
-ULONG PUBLIC
-DispatchPageGadget(reg (a0) Class *cl, reg (a2) Object *o, reg (a1) Msg msg)
+IPTR PUBLIC
+DispatchPageGadget(REG(a0, Class *cl), REG(a2, Object *o), REG(a1, Msg msg))
 {
 	struct PageGData *pd = INST_DATA(cl, o);
-	ULONG retval = 0;
+	IPTR retval = 0;
 	long i;
 
 	switch (msg-&gt;MethodID) {
 		case OM_NEW:
-			if (retval = DoSuperMethodA(cl, o, msg)) {
+			if ((retval = DoSuperMethodA(cl, o, msg)) != 0) {
 				struct Gadget *gad;
 
 				pd = INST_DATA(cl, retval);
 				pd-&gt;pd_Active = GetTagData(PAGEGA_Active, 0L, ((struct opSet *)msg)-&gt;ops_AttrList);
-				pd-&gt;pd_Pages = (struct Gadget **)GetTagData(PAGEGA_Pages, NULL, ((struct opSet *)msg)-&gt;ops_AttrList);
-				pd-&gt;pd_Refresh = (APTR)GetTagData(PAGEGA_RefreshFunc, NULL, ((struct opSet *)msg)-&gt;ops_AttrList);
+				pd-&gt;pd_Pages = (struct Gadget **)GetTagData(PAGEGA_Pages, 0, ((struct opSet *)msg)-&gt;ops_AttrList);
+				pd-&gt;pd_Refresh = (APTR)GetTagData(PAGEGA_RefreshFunc, 0, ((struct opSet *)msg)-&gt;ops_AttrList);
 				
 				// Count pages and gadgets in the pages
 				for (i = 0; pd-&gt;pd_Pages[i]; i++);
@@ -129,7 +130,7 @@
 				struct RastPort *rp;
 
 				tstate = ((struct opSet *)msg)-&gt;ops_AttrList;
-				while (ti = NextTagItem(&amp;tstate)) {
+				while ((ti = NextTagItem(&amp;tstate)) != 0) {
 					switch (ti-&gt;ti_Tag) {
 						case PAGEGA_Active:
 							i = ti-&gt;ti_Data;
@@ -218,7 +219,7 @@
 	if (all) {  // draw the whole gadget
 		APTR obj;
 
-		if (obj = NewObject(NULL, &quot;frameiclass&quot;, IA_Width, gad-&gt;Width, IA_Height, gad-&gt;Height - h, IA_EdgesOnly, TRUE, TAG_END)) {
+		if ((obj = NewObject(NULL, &quot;frameiclass&quot;, IA_Width, gad-&gt;Width, IA_Height, gad-&gt;Height - h, IA_EdgesOnly, TRUE, TAG_END)) != 0) {
 			DrawImage(rp, obj, gad-&gt;LeftEdge, gad-&gt;TopEdge + h);
 			DisposeObject(obj);
 		}
@@ -349,10 +350,10 @@
 }
 
 
-ULONG PUBLIC
-DispatchIndexGadget(reg (a0) Class *cl, reg (a2) Object *o, reg (a1) Msg msg)
+IPTR PUBLIC
+DispatchIndexGadget(REG(a0, Class *cl), REG(a2, Object *o), REG(a1, Msg msg))
 {
-	ULONG retval = 0;
+	IPTR retval = 0;
 	struct IndexGData *id;
 	long i;
 
@@ -360,9 +361,9 @@
 
 	switch(msg-&gt;MethodID) {
 		case OM_NEW:
-			if (!GetTagData(GA_DrawInfo,NULL,((struct opSet *)msg)-&gt;ops_AttrList))
+			if (!GetTagData(GA_DrawInfo, 0, ((struct opSet *)msg)-&gt;ops_AttrList))
 				break;
-			if (retval = DoSuperMethodA(cl, o, msg)) {
+			if ((retval = DoSuperMethodA(cl, o, msg)) != 0) {
 				id = INST_DATA(cl,retval);
 				id-&gt;id_Active = id-&gt;id_Current = id-&gt;id_NewCurrent = GetTagData(IGA_Active,0L,((struct opSet *)msg)-&gt;ops_AttrList);
 				id-&gt;id_Labels = (STRPTR *)GetTagData(IGA_Labels,0L,((struct opSet *)msg)-&gt;ops_AttrList);
@@ -390,7 +391,7 @@
 				struct TagItem *tstate,*ti;
 
 				tstate = ((struct opSet *)msg)-&gt;ops_AttrList;
-				while (ti = NextTagItem(&amp;tstate)) {
+				while ((ti = NextTagItem(&amp;tstate)) != 0) {
 					switch (ti-&gt;ti_Tag) {
 						case IGA_Active:
 							id-&gt;id_Active = id-&gt;id_NewCurrent = ti-&gt;ti_Data;
@@ -483,7 +484,6 @@
 	return retval;
 }
 
-
 /********************************** Frames-Gadget **********************************/
 
 
@@ -581,10 +581,10 @@
 
 	if (all) {
 		// draw the whole gadget
-		if (img = NewObject(NULL,&quot;frameiclass&quot;,
+		if ((img = NewObject(NULL,&quot;frameiclass&quot;,
 				IA_Width,  stdframe_width,
 				IA_Height, stdframe_height,
-				TAG_END)) {
+				TAG_END)) != 0) {
 			for (x = 0, y = 0; y &lt; stdframe_rows; x++) {
 				if (x &gt;= stdframe_cols)
 					x = 0,y++;
@@ -597,24 +597,30 @@
 		}
 	}
 	if (stdframe_new != stdframe_active) {
-		if (stdframe_active != ~0L)
-			EraseFatRect(rp,x = gad-&gt;LeftEdge+(stdframe_width+3)*(stdframe_active % stdframe_cols)-2,y = gad-&gt;TopEdge+(stdframe_height+3)*(stdframe_active/stdframe_cols)-2,x+stdframe_width+3,y+stdframe_height+3);
+		if (stdframe_active != ~0L) {
+			x = gad-&gt;LeftEdge + (stdframe_width + 3) * (stdframe_active % stdframe_cols) - 2;
+			y = gad-&gt;TopEdge + (stdframe_height + 3) * (stdframe_active / stdframe_cols) - 2;
+			EraseFatRect(rp, x, y, x + stdframe_width + 3, y + stdframe_height + 3);
+		}
 		SetAPen(rp,3);  stdframe_active = stdframe_new;
-		if (stdframe_active != ~0L)
-			DrawFatRect(rp,x = gad-&gt;LeftEdge+(stdframe_width+3)*(stdframe_active % stdframe_cols)-2,y = gad-&gt;TopEdge+(stdframe_height+3)*(stdframe_active/stdframe_cols)-2,x+stdframe_width+3,y+stdframe_height+3);
+		if (stdframe_active != ~0L)	{
+			x = gad-&gt;LeftEdge + (stdframe_width + 3) * (stdframe_active % stdframe_cols) - 2;
+			y = gad-&gt;TopEdge + (stdframe_height + 3) * (stdframe_active / stdframe_cols) - 2;
+			DrawFatRect(rp ,x ,y ,x + stdframe_width + 3, y + stdframe_height + 3);
+		}
 	}
 }
 
 
-ULONG PUBLIC
-DispatchFramesGadget(reg (a0) Class *cl, reg (a2) Object *o, reg (a1) Msg msg)
+IPTR PUBLIC
+DispatchFramesGadget(REG(a0, Class *cl), REG(a2, Object *o), REG(a1, Msg msg))
 {
-	ULONG retval = 0;
+	IPTR retval = 0;
 	long x, y;
 
 	switch (msg-&gt;MethodID) {
 		case OM_NEW:
-			if (retval = DoSuperMethodA(cl,o,msg))
+			if ((retval = DoSuperMethodA(cl,o,msg)) != 0)
 				SetAttrs((Object *)retval,GA_RelVerify,TRUE,TAG_END);
 			break;
 		case GM_DOMAIN:
@@ -686,8 +692,8 @@
 /********************************** PopUp-Image **********************************/
 
 
-ULONG PUBLIC
-DispatchPopUpImage(reg (a0) Class *cl, reg (a2) Object *o, reg (a1) Msg msg)
+IPTR PUBLIC
+DispatchPopUpImage(REG(a0, Class *cl), REG(a2, Object *o), REG(a1, Msg msg))
 {
 	if (msg-&gt;MethodID == IM_DRAW || msg-&gt;MethodID == IM_DRAWFRAME) {
 		/*struct impDraw *imp = (struct impDraw *)msg;
@@ -718,8 +724,8 @@
 /********************************** Bitmap-Image **********************************/
 
 
-ULONG PUBLIC
-DispatchBitmapImage(reg (a0) Class *cl, reg (a2) Object *o, reg (a1) Msg msg)
+IPTR PUBLIC
+DispatchBitmapImage(REG(a0, Class *cl), REG(a2, Object *o), REG(a1, Msg msg))
 {
 	struct BitmapIData *bd;
 
@@ -730,10 +736,10 @@
 		{
 			Object *this;
 
-			if (this = (Object *)DoSuperMethodA(cl, o, msg)) {
+			if ((this = (Object *)DoSuperMethodA(cl, o, msg))) {
 				bd = INST_DATA(cl,this);
-				bd-&gt;bd_Bitmap = (struct BitMap *)GetTagData(BIA_Bitmap,NULL,((struct opSet *)msg)-&gt;ops_AttrList);
-				bd-&gt;bd_SelectedBitmap = (struct BitMap *)GetTagData(BIA_SelectedBitmap,NULL,((struct opSet *)msg)-&gt;ops_AttrList);
+				bd-&gt;bd_Bitmap = (struct BitMap *)GetTagData(BIA_Bitmap, 0, ((struct opSet *)msg)-&gt;ops_AttrList);
+				bd-&gt;bd_SelectedBitmap = (struct BitMap *)GetTagData(BIA_SelectedBitmap, 0, ((struct opSet *)msg)-&gt;ops_AttrList);
 			}
 			return (ULONG)this;
 		}
@@ -789,7 +795,7 @@
 ULONG
 GetBestPictureModeID(ULONG width, ULONG height, ULONG depth)
 {
-	ULONG mode_id = NULL;
+	ULONG mode_id = 0;
 
 	mode_id = BestModeID(BIDTAG_NominalWidth,	width,
 						 BIDTAG_NominalHeight,	height,
@@ -849,11 +855,11 @@
 
 			TRACE((&quot;loading true color image...\n&quot;));
 
-			if (pic = NewObject(NULL, &quot;picture.datatype&quot;,
+			if ((pic = NewObject(NULL, &quot;picture.datatype&quot;,
 					DTA_ObjName,	pd-&gt;pd_Name ? pd-&gt;pd_Name : (STRPTR)&quot;image&quot;, PDTA_Screen,  scr,
 					PDTA_Remap,		TRUE,
 					DTA_Name,		&quot;picture&quot;,
-					TAG_END))
+					TAG_END)) != 0)
 			{
 				ULONG tags[] = {LBMI_WIDTH, 0, LBMI_HEIGHT, 0, LBMI_PIXFMT, 0, LBMI_BYTESPERROW, 0, LBMI_BASEADDRESS, 0, TAG_END};
 				ULONG mod, format, w, h, data;
@@ -871,7 +877,7 @@
 				tags[1] = (ULONG)&w;  tags[3] = (ULONG)&h;
 				tags[5] = (ULONG)&format;  tags[7] = (ULONG)&mod;  tags[9] = (ULONG)&data;
 
-				if (handle = LockBitMapTagList(bm, (struct TagItem *)tags)) {
+				if ((handle = LockBitMapTagList(bm, (struct TagItem *)tags)) != 0) {
 					if (format == PIXFMT_RGB24)
 						format = PBPAFMT_RGB;
 					else if (format == PIXFMT_RGBA32)
@@ -886,7 +892,7 @@
 			bm = NULL;
 		} else {
 			/* clut/standard bitmap */
-			if (bm = AllocBitMap(im-&gt;Width, im-&gt;Height, pd-&gt;pd_Depth, BMF_MINPLANES, pd-&gt;pd_BitMap))
+			if ((bm = AllocBitMap(im-&gt;Width, im-&gt;Height, pd-&gt;pd_Depth, BMF_MINPLANES, pd-&gt;pd_BitMap)) != 0)
 				BltBitMap(pd-&gt;pd_BitMap, 0, 0, bm, 0, 0, im-&gt;Width, im-&gt;Height, 0xc0, 0xff, NULL);
 
 			TRACE((&quot;setting CLUT8 picture data...\n&quot;));
@@ -954,14 +960,14 @@
 
 		cols = 1 &lt;&lt; depth;
 
-		if (pd-&gt;pd_ColorMap = AllocVec(sizeof(struct ColorRegister) * cols, MEMF_PUBLIC)) {
+		if ((pd-&gt;pd_ColorMap = AllocVec(sizeof(struct ColorRegister) * cols, MEMF_PUBLIC)) != 0) {
 			for (i = 0;i &lt; cols;i++) {
 				pd-&gt;pd_ColorMap[i].red =	cregs[i * 3 + 0];
 				pd-&gt;pd_ColorMap[i].green = cregs[i * 3 + 1];
 				pd-&gt;pd_ColorMap[i].blue =  cregs[i * 3 + 2];
 			}
 
-			if (pd-&gt;pd_ColorRegs = AllocVec(sizeof(LONG) * 3 * cols, MEMF_PUBLIC)) {
+			if ((pd-&gt;pd_ColorRegs = AllocVec(sizeof(LONG) * 3 * cols, MEMF_PUBLIC)) != 0) {
 				CopyMem(cregs, pd-&gt;pd_ColorRegs, sizeof(LONG) * 3 * cols);
 
 				pd-&gt;pd_NumColors = cols;
@@ -970,7 +976,7 @@
 				im-&gt;Width = width;
 				im-&gt;Height = height;
 
-				if (pd-&gt;pd_SourceBitMap = AllocBitMap(width, height, depth, 0, NULL)) {
+				if ((pd-&gt;pd_SourceBitMap = AllocBitMap(width, height, depth, 0, NULL))) {
 					BltBitMap(&amp;bm, 0, 0, pd-&gt;pd_SourceBitMap, 0, 0, width, height, 0xc0, 0xff, NULL);
 					return TRUE;
 				}
@@ -996,9 +1002,9 @@
 						PDTA_BitMapHeader,		&amp;bmh,
 						TAG_DONE) &gt; 4) {
 		if (bm &amp;&amp; cregs &amp;&amp; cmap &amp;&amp; bmh) {
-			if (pd-&gt;pd_ColorMap = AllocVec(sizeof(struct ColorRegister) * cols, MEMF_PUBLIC)) {
+			if ((pd-&gt;pd_ColorMap = AllocVec(sizeof(struct ColorRegister) * cols, MEMF_PUBLIC)) != 0) {
 				CopyMem(cmap, pd-&gt;pd_ColorMap, sizeof(struct ColorRegister) * cols);
-				if (pd-&gt;pd_ColorRegs = AllocVec(sizeof(LONG) * 3 * cols, MEMF_PUBLIC)) {
+				if ((pd-&gt;pd_ColorRegs = AllocVec(sizeof(LONG) * 3 * cols, MEMF_PUBLIC)) != 0) {
 					CopyMem(cregs, pd-&gt;pd_ColorRegs, sizeof(LONG) * 3 * cols);
 
 					pd-&gt;pd_NumColors = cols;
@@ -1007,7 +1013,7 @@
 					im-&gt;Width = bmh-&gt;bmh_Width;
 					im-&gt;Height = bmh-&gt;bmh_Height;
 
-					if (pd-&gt;pd_SourceBitMap = AllocBitMap(bmh-&gt;bmh_Width, bmh-&gt;bmh_Height, bmh-&gt;bmh_Depth, BMF_MINPLANES, bm)) {
+					if ((pd-&gt;pd_SourceBitMap = AllocBitMap(bmh-&gt;bmh_Width, bmh-&gt;bmh_Height, bmh-&gt;bmh_Depth, BMF_MINPLANES, bm)) != 0) {
 						BltBitMap(bm, 0, 0, pd-&gt;pd_SourceBitMap, 0, 0, im-&gt;Width, im-&gt;Height, 0xc0, 0xff, NULL);
 						return TRUE;
 					}
@@ -1030,7 +1036,7 @@
 	};
 	Object *obj;
 
-	if (obj = NewDTObjectA(pd-&gt;pd_Name, (struct TagItem *)tags)) {
+	if ((obj = NewDTObjectA(pd-&gt;pd_Name, (struct TagItem *)tags)) != 0) {
 		if (DoMethod(obj, DTM_PROCLAYOUT, NULL, 1) &amp;&amp; CopyFromPictureObject(pd, obj, im)) {
 			DisposeDTObject(obj);
 			SetPictureScreen(pd, im, pd-&gt;pd_Screen);
@@ -1042,24 +1048,24 @@
 }
 
 
-ULONG PUBLIC
-DispatchPictureImage(reg (a0) Class *cl, reg (a2) Object *o, reg (a1) Msg msg)
+IPTR PUBLIC
+DispatchPictureImage(REG(a0, Class *cl), REG(a2, Object *o), REG(a1, Msg msg))
 {
 	struct PictureIData *pd;
-	ULONG  retval = 0;
+	IPTR   retval = 0;
 
 	pd = INST_DATA(cl, o);
 
 	switch (msg-&gt;MethodID) {
 		case OM_NEW:
-			if (retval = DoSuperMethodA(cl, o, msg)) {
+			if ((retval = DoSuperMethodA(cl, o, msg)) != 0) {
 				pd = INST_DATA(cl, retval);
-				pd-&gt;pd_Screen = (struct Screen *)GetTagData(PDTA_Screen, NULL, ((struct opSet *)msg)-&gt;ops_AttrList);
+				pd-&gt;pd_Screen = (struct Screen *)GetTagData(PDTA_Screen, 0, ((struct opSet *)msg)-&gt;ops_AttrList);
 
 				IM(retval)-&gt;Height = 5;
 				IM(retval)-&gt;Width = 5;
 
-				if (pd-&gt;pd_Name = AllocString((STRPTR)GetTagData(DTA_Name, NULL, ((struct opSet *)msg)-&gt;ops_AttrList))) {
+				if ((pd-&gt;pd_Name = AllocString((STRPTR)GetTagData(DTA_Name, 0, ((struct opSet *)msg)-&gt;ops_AttrList))) != 0) {
 					if (!GetTagData(PIA_DelayLoad, FALSE, ((struct opSet *)msg)-&gt;ops_AttrList)) {
 						if (LoadPictureObject(pd, (struct Image *)retval))
 							break;
@@ -1069,8 +1075,8 @@
 					struct Image *im;
 					LONG *cregs;
 
-					if (im = (APTR)GetTagData(PIA_FromImage, NULL, ((struct opSet *)msg)-&gt;ops_AttrList)) {
-						if (cregs = (APTR)GetTagData(PIA_WithColors, NULL, ((struct opSet *)msg)-&gt;ops_AttrList)) {
+					if ((im = (APTR)GetTagData(PIA_FromImage, 0, ((struct opSet *)msg)-&gt;ops_AttrList)) != 0) {
+						if ((cregs = (APTR)GetTagData(PIA_WithColors, 0, ((struct opSet *)msg)-&gt;ops_AttrList)) != 0) {
 							if (CopyFromPictureImage(pd, im, cregs, (struct Image *)retval)) {
 								SetPictureScreen(pd, (struct Image *)retval, pd-&gt;pd_Screen);
 								break;
@@ -1079,7 +1085,7 @@
 					}
 				}
 				DoSuperMethod(cl, (Object *)retval, OM_DISPOSE);
-				retval = NULL;
+				retval = 0;
 			}
 			break;
 		case OM_DISPOSE:
@@ -1099,7 +1105,7 @@
 			struct TagItem *ti;
 
 			retval = DoSuperMethodA(cl, o, msg);
-			if (ti = FindTagItem(PDTA_Screen, ((struct opSet *)msg)-&gt;ops_AttrList)) {
+			if ((ti = FindTagItem(PDTA_Screen, ((struct opSet *)msg)-&gt;ops_AttrList)) != 0) {
 				if (pd-&gt;pd_SourceBitMap)
 					SetPictureScreen(pd, (struct Image *)o, (struct Screen *)ti-&gt;ti_Data);
 				else if (pd-&gt;pd_Name) {
@@ -1143,10 +1149,10 @@
 /********************************** Button-Class **********************************/
 
 
-ULONG PUBLIC
-DispatchButton(reg (a0) Class *cl, reg (a2) Object *o, reg (a1) Msg msg)
+IPTR PUBLIC
+DispatchButton(REG(a0, Class *cl), REG(a2, Object *o), REG(a1, Msg msg))
 {
-	ULONG  rc;
+	IPTR  rc;
 
 	switch(msg-&gt;MethodID) {
 		case GM_GOACTIVE:
@@ -1226,7 +1232,7 @@
 	struct TagItem *ti;
 	ULONG pen = cd-&gt;cd_Pen;
 
-	while (ti = NextTagItem(&amp;tstate)) {
+	while ((ti = NextTagItem(&amp;tstate))) {
 		switch (ti-&gt;ti_Tag) {
 			case CGA_Color:
 				cd-&gt;cd_Color = ti-&gt;ti_Data;
@@ -1248,17 +1254,17 @@
 }
 
 
-ULONG PUBLIC
-DispatchColorButton(reg (a0) Class *cl, reg (a2) struct Gadget *gad, reg (a1) Msg msg)
+IPTR PUBLIC
+DispatchColorButton(REG(a0, Class *cl), REG(a2, struct Gadget *gad), REG(a1, Msg msg))
 {
 	struct ColorGData *cd;
-	ULONG rc = 0L;
+	IPTR rc = 0L;
 
 	cd = INST_DATA(cl,gad);
 
 	switch (msg-&gt;MethodID) {
 		case OM_NEW:
-			if (rc = DoSuperMethodA(cl, (Object *)gad, msg)) {
+			if ((rc = DoSuperMethodA(cl, (Object *)gad, msg)) != 0) {
 				cd = INST_DATA(cl, rc);
 				SetAttrs((APTR)rc, GA_RelVerify, TRUE, TAG_END);
 				SetColorButton((struct Gadget *)rc, NULL, cd, ((struct opSet *)msg)-&gt;ops_AttrList);
@@ -1308,10 +1314,9 @@
 /********************************** Icon-Obj **********************************/
 
 
-ULONG PUBLIC
-DispatchIconObj(reg (a0) Class *cl,reg (a2) Object *o,reg (a1) Msg msg)
+IPTR PUBLIC
+DispatchIconObj(REG(a0, Class *cl), REG(a2, Object *o), REG(a1, Msg msg))
 {
-
 	switch (msg-&gt;MethodID) {
 		case GM_GOACTIVE:
 		case GM_HANDLEINPUT:
@@ -1359,46 +1364,44 @@
 void
 InitAppClasses(void)
 {
-	fillHook.h_Entry = (ULONG (*)())fillHookFunc;
-	renderHook.h_Entry = (ULONG (*)())RenderHook;
-	formelHook.h_Entry = (ULONG (*)())FormelHook;
-	formatHook.h_Entry = (ULONG (*)())FormatHook;
-	glinkHook.h_Entry = (ULONG (*)())gLinkHook;
-	linkHook.h_Entry = (ULONG (*)())LinkHook;
-	colorHook.h_Entry = (ULONG (*)())ColorHook;
-	selectHook.h_Entry = (ULONG (*)())SelectHook;
-	popUpHook.h_Entry = (ULONG (*)())PopUpHook;
-	fileHook.h_Entry = (ULONG (*)())HandleFileTypeIDCMP;
+	SETHOOK(fillHook, fillHookFunc);
+	SETHOOK(renderHook, RenderHook);
+	SETHOOK(formelHook, FormelHook);
+	SETHOOK(formatHook, FormatHook);
+	SETHOOK(glinkHook, gLinkHook);
+	SETHOOK(linkHook, LinkHook);
+	SETHOOK(colorHook, ColorHook);
+	SETHOOK(selectHook, SelectHook);
+	SETHOOK(popUpHook, PopUpHook);
+	SETHOOK(fileHook, HandleFileTypeIDCMP);
 
 	CopyMem(GTD_GetHook(GTDH_TREE),&amp;treeHook,sizeof(struct Hook));
 
-	if (buttonclass = MakeClass(NULL,&quot;buttongclass&quot;,NULL,0,0))
-		buttonclass-&gt;cl_Dispatcher.h_Entry = (ULONG (*)())DispatchButton;
+	if ((buttonclass = MakeClass(NULL, &quot;buttongclass&quot;, NULL, 0, 0)) != 0)
+		SETDISPATCHER(buttonclass, DispatchButton);
 
-	if (colorgclass = MakeClass(NULL,&quot;buttongclass&quot;,NULL,sizeof(struct ColorGData),0))
-		colorgclass-&gt;cl_Dispatcher.h_Entry = (ULONG (*)())DispatchColorButton;
+	if ((colorgclass = MakeClass(NULL, &quot;buttongclass&quot;, NULL, sizeof(struct ColorGData), 0)) != 0)
+		SETDISPATCHER(colorgclass, DispatchColorButton);
 
-	if (iconobjclass = MakeClass(NULL,&quot;frbuttonclass&quot;,NULL,0,0))
-		iconobjclass-&gt;cl_Dispatcher.h_Entry = (ULONG (*)())DispatchIconObj;
+	if ((iconobjclass = MakeClass(NULL, &quot;frbuttonclass&quot;, NULL, 0, 0)) != 0)
+		SETDISPATCHER(iconobjclass, DispatchIconObj);
 
-	if (pagegclass = MakeClass(NULL,&quot;gadgetclass&quot;,NULL,sizeof(struct PageGData),0))
-		pagegclass-&gt;cl_Dispatcher.h_Entry = (ULONG (*)())DispatchPageGadget;
+	if ((pagegclass = MakeClass(NULL, &quot;gadgetclass&quot;, NULL, sizeof(struct PageGData), 0)) != 0)
+		SETDISPATCHER(pagegclass, DispatchPageGadget);
 
-	if (indexgclass = MakeClass(NULL,&quot;gadgetclass&quot;,NULL,sizeof(struct IndexGData),0))
-		indexgclass-&gt;cl_Dispatcher.h_Entry = (ULONG (*)())DispatchIndexGadget;
+	if ((indexgclass = MakeClass(NULL, &quot;gadgetclass&quot;, NULL, sizeof(struct IndexGData), 0)) != 0)
+		SETDISPATCHER(indexgclass, DispatchIndexGadget);
 
-	if (framesgclass = MakeClass(NULL,&quot;gadgetclass&quot;,NULL,0,0))
-		framesgclass-&gt;cl_Dispatcher.h_Entry = (ULONG (*)())DispatchFramesGadget;
+	if ((framesgclass = MakeClass(NULL, &quot;gadgetclass&quot;, NULL, 0, 0)) != 0)
+		SETDISPATCHER(framesgclass, DispatchFramesGadget);
 
-	if (pictureiclass = MakeClass(NULL,&quot;imageclass&quot;,NULL,sizeof(struct PictureIData),0)) {
-		pictureiclass-&gt;cl_Dispatcher.h_Entry = (ULONG (*)())DispatchPictureImage;
-		pictureiclass-&gt;cl_UserData = (ULONG)OpenLibrary(&quot;datatypes/picture.datatype&quot;,39);
+	if ((pictureiclass = MakeClass(NULL, &quot;imageclass&quot;, NULL, sizeof(struct PictureIData), 0)) != 0) {
+		SETDISPATCHER(pictureiclass, DispatchPictureImage);
+		pictureiclass-&gt;cl_UserData = (IPTR)OpenLibrary(&quot;datatypes/picture.datatype&quot;,39);
 	}
-	if (bitmapiclass = MakeClass(NULL,&quot;imageclass&quot;,NULL,sizeof(struct BitmapIData),0))
-		bitmapiclass-&gt;cl_Dispatcher.h_Entry = (ULONG (*)())DispatchBitmapImage;
+	if ((bitmapiclass = MakeClass(NULL, &quot;imageclass&quot;, NULL, sizeof(struct BitmapIData), 0)) != 0)
+		SETDISPATCHER(bitmapiclass, DispatchBitmapImage);
 
-	if (popupiclass = MakeClass(NULL,&quot;imageclass&quot;,NULL,0,0))
-		popupiclass-&gt;cl_Dispatcher.h_Entry = (ULONG (*)())DispatchPopUpImage;
+	if ((popupiclass = MakeClass(NULL, &quot;imageclass&quot;, NULL, 0, 0)) != 0)
+		SETDISPATCHER(popupiclass, DispatchPopUpImage);
 }
-
-


Property changes on: trunk/boopsi.c
___________________________________________________________________
Name: svn:keywords
   + Author Date Id Revision
Name: svn:eol-style
   + native

Modified: trunk/calc.c
===================================================================
--- trunk/calc.c	2008-12-13 10:00:37 UTC (rev 14)
+++ trunk/calc.c	2008-12-14 22:41:08 UTC (rev 15)
@@ -19,7 +19,12 @@
 STRPTR tf_format, gTextBuffer, itaPoint;
 UWORD calcerr, calcflags = CF_REQUESTER;
 long mday[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
-struct FormatVorlage empty_fv = {NULL, NULL, FVT_NONE, 0, NULL, NULL, 0, 0, 0, 0};
+#if defined(__AROS__) &amp;&amp; !(AROS_FLAVOUR &amp; AROS_FLAVOUR_BINCOMPAT)
+#warning FIXME when V1 ABI is out
+struct FormatVorlage empty_fv = {{NULL, NULL, NULL, FVT_NONE, 0}, NULL, 0, 0, 0, 0};
+#else
+struct FormatVorlage empty_fv = {{NULL, NULL, FVT_NONE, 0, NULL}, NULL, 0, 0, 0, 0};
+#endif
 struct MinList flangs;
 APTR tree_stack;
 ULONG tree_size;
@@ -38,7 +43,7 @@
     char   c,intext;
     long   i,l;
 
-    for (i = 0, intext = FALSE, l = 0; c = *(st + i); i++)
+    for (i = 0, intext = FALSE, l = 0; (c = *(st + i)) != 0; i++)
     {
         if (c == intext)
             intext = 0;
@@ -50,7 +55,7 @@
     if (!(t = AllocPooled(pool, strlen(st) - l + 1)))
         return NULL;
 
-    for (i = 0,l = 0,intext = FALSE;c = *(st+i);*(t+l++) = *(st+i++))
+    for (i = 0, l = 0, intext = FALSE; (c = *(st+i)) != 0; *(t+l++) = *(st+i++))
     {
         if (c == intext)
             intext = 0;
@@ -79,7 +84,7 @@
         // enlarge buffer
         STRPTR t;
 
-        if (t = AllocPooled(pool, gTextBufferLength + 256))
+        if ((t = AllocPooled(pool, gTextBufferLength + 256)) != 0)
         {
             strcpy(t, gTextBuffer);
             FreePooled(pool, gTextBuffer, gTextBufferLength);
@@ -141,7 +146,7 @@
  */
 
 STRPTR PUBLIC
-AbsCoord2String(reg (d0) BOOL abscol, reg (d1) long col, reg (d2) BOOL absrow, reg (d3) long row)
+AbsCoord2String(REG(d0, BOOL abscol), REG(d1, long col), REG(d2, BOOL absrow), REG(d3, long row))
 {
     static char t[16];
 
@@ -197,23 +202,25 @@
     /*if (!t-&gt;t_Mappe)*/
     {
         if (t-&gt;t_Page)
-            page = (struct Page *)FindName(&amp;calcpage-&gt;pg_Mappe-&gt;mp_Pages,t-&gt;t_Page);
+            page = (struct Page *)MyFindName(&amp;calcpage-&gt;pg_Mappe-&gt;mp_Pages, t-&gt;t_Page);
         if (!page)
             page = (struct Page *)FindListNumber(&amp;calcpage-&gt;pg_Mappe-&gt;mp_Pages,t-&gt;t_NumPage-1);
     }
-    /*else
+#if 0
+    else
     {
         D(bug(&quot;not implemented\n&quot;));
-        /*if (mp = (struct Mappe *)FindName(&amp;calcpage-&gt;pg_Mappe-&gt;mp_Projects,t-&gt;t_Mappe))
+        /*if (mp = (struct Mappe *)MyFindName(&amp;calcpage-&gt;pg_Mappe-&gt;mp_Projects,t-&gt;t_Mappe))
         {
             if (t-&gt;t_NumPage == -1)
-                page = (struct Page *)FindName(&amp;mp-&gt;mp_Pages,t-&gt;t_Page);
+                page = (struct Page *)MyFindName(&amp;mp-&gt;mp_Pages,t-&gt;t_Page);
             else
                 page = (struct Page *)FindListNumber(&amp;mp-&gt;mp_Pages,t-&gt;t_NumPage);
         }*/
         /*if (mp = (struct Mappe *)FindListNumber(&amp;calcpage-&gt;pg_Mappe-&gt;mp_Projects,t-&gt;t_Mappe-1))
             page = (struct Page *)FindListNumber(&amp;mp-&gt;mp_Pages,t-&gt;t_Page-1);*/
-    }*/
+    }
+#endif
     return page;
 }
 
@@ -223,7 +230,7 @@
 {
     struct Page *page;
 
-    if (page = GetExtCalcPage(t))
+    if ((page = GetExtCalcPage(t)) != 0)
         return GetTableField(page,t-&gt;t_Col,t-&gt;t_Row);
 
     return NULL;
@@ -320,7 +327,7 @@
     {
         APTR temp;
 
-        if (temp = AllocPooled(pool,(grc_count + 2) * sizeof(ULONG)))
+        if ((temp = AllocPooled(pool, (grc_count + 2) * sizeof(ULONG))) != 0)
         {
             if (grc_base)
             {
@@ -357,9 +364,9 @@
             if (tl-&gt;t_Op == OP_EXTCELL &amp;&amp; tr-&gt;t_Op == OP_EXTCELL &amp;&amp; !stricmp(tl-&gt;t_Page,tr-&gt;t_Page))
             {
                 if (tl-&gt;t_Col &gt; tr-&gt;t_Col)
-                    swmem(&amp;tl-&gt;t_Col,&amp;tr-&gt;t_Col,sizeof(LONG));
+                    swmem((UBYTE *)&amp;tl-&gt;t_Col, (UBYTE *)&amp;tr-&gt;t_Col, sizeof(LONG));
                 if (tl-&gt;t_Row &gt; tr-&gt;t_Row)
-                    swmem(&amp;tl-&gt;t_Row,&amp;tr-&gt;t_Row,sizeof(LONG));
+                    swmem((UBYTE *)&amp;tl-&gt;t_Row, (UBYTE *)&amp;tr-&gt;t_Row, sizeof(LONG));
 
                 tp.tp_Col = tl-&gt;t_Col;
                 tp.tp_Row = tl-&gt;t_Row;
@@ -430,7 +437,7 @@
     if (t-&gt;t_Op == OP_NAME)
     {
         calcpage = rxpage;
-        if (nm = GetName(t-&gt;t_Text))
+        if ((nm = GetName(t-&gt;t_Text)) != 0)
             t = nm-&gt;nm_Root;
     }
     if (t-&gt;t_Op == OP_CELL)
@@ -446,12 +453,12 @@
     {
         if ((tl-&gt;t_AbsCol ? 0 : tf_col)+tl-&gt;t_Col &gt; (tr-&gt;t_AbsCol ? 0 : tf_col)+tr-&gt;t_Col)
         {
-            swmem(&amp;tl-&gt;t_Col,&amp;tr-&gt;t_Col,sizeof(LONG));
-            swmem(&amp;tl-&gt;t_AbsCol,&amp;tr-&gt;t_AbsCol,sizeof(BOOL));
+            swmem((UBYTE *)&amp;tl-&gt;t_Col, (UBYTE *)&amp;tr-&gt;t_Col, sizeof(LONG));
+            swmem(&amp;tl-&gt;t_AbsCol, &amp;tr-&gt;t_AbsCol, sizeof(BOOL));
         }
         if ((tl-&gt;t_AbsRow ? 0 : tf_row)+tl-&gt;t_Row &gt; (tr-&gt;t_AbsRow ? 0 : tf_row)+tr-&gt;t_Row)
         {
-            swmem(&amp;tl-&gt;t_Row,&amp;tr-&gt;t_Row,sizeof(LONG));
+            swmem((UBYTE *)&amp;tl-&gt;t_Row,(UBYTE *)&amp;tr-&gt;t_Row,sizeof(LONG));
             swmem(&amp;tl-&gt;t_AbsRow,&amp;tr-&gt;t_AbsRow,sizeof(BOOL));
         }
         tp-&gt;tp_Col = tl-&gt;t_Col+(tl-&gt;t_AbsCol ? 0 : tf_col);
@@ -640,7 +647,7 @@
         {
             if (t[len] == '.' &amp;&amp; fi-&gt;fi_Node.ln_Type == FIT_REFERENCE)
             {
-                *db = (APTR)FindName(&amp;mp-&gt;mp_Databases,fi-&gt;fi_Special);
+                *db = (APTR)MyFindName(&amp;mp-&gt;mp_Databases, fi-&gt;fi_Special);
                 return GetNameDatabaseField(mp, db, t + len + 1, sfi, pos);
             }
             else if (!t[len])
@@ -686,7 +693,7 @@
         if (!fi || !fi-&gt;fi_Node.ln_Succ)
             return false;
     }
-    else if (t = strchr(t, '.')) /* Der Punkt markiert Felder in Datenbanken - bei normalen Namen ist er unzul&#228;ssig */
+    else if ((t = strchr(t, '.')) != 0) /* Der Punkt markiert Felder in Datenbanken - bei normalen Namen ist er unzul&#228;ssig */
     {
         if (db-&gt;db_Node.ln_Type != NMT_DATABASE)
             return false;
@@ -760,7 +767,7 @@
 void
 CalcError(long err)
 {
-    STRPTR t = NULL;
+    CONST_STRPTR t = NULL;
 
     if (!err || !(calcflags &amp; CF_REQUESTER))
         return;
@@ -808,7 +815,7 @@
 
 
 int32 PUBLIC
-CalcTree(reg (a0) struct Result *r,reg (a1) struct Term *t)
+CalcTree(REG(a0, struct Result *r), REG(a1, struct Term *t))
 {
     struct Result r1,r2;
     struct tableField *tf;
@@ -820,9 +827,9 @@
     memset(&amp;r1,0,sizeof(struct Result));  memset(&amp;r2,0,sizeof(struct Result));
     if (t-&gt;t_Op != OP_RANGE)
     {
-        if (rc = CalcTree(&amp;r1,t-&gt;t_Left))
+        if ((rc = CalcTree(&amp;r1, t-&gt;t_Left)) != 0)
             return rc;
-        if (rc = CalcTree(&amp;r2,t-&gt;t_Right))
+        if ((rc = CalcTree(&amp;r2, t-&gt;t_Right)) != 0)
         {
             FreeString(r1.r_Text);
             return rc;
@@ -903,7 +910,7 @@
             }
             if (r1.r_Type &amp; RT_TEXT &amp;&amp; r2.r_Type &amp; RT_TEXT)
             {
-                if (r-&gt;r_Text = AllocPooled(pool,(r1.r_Text ? strlen(r1.r_Text) : 0)+(r2.r_Text ? strlen(r2.r_Text) : 0)+1))
+                if ((r-&gt;r_Text = AllocPooled(pool,(r1.r_Text ? strlen(r1.r_Text) : 0)+(r2.r_Text ? strlen(r2.r_Text) : 0)+1)) != 0)
                 {
                     if (r1.r_Text)
                         strcpy(r-&gt;r_Text,r1.r_Text);
@@ -975,7 +982,7 @@
         case OP_RANGE:
             r1.r_Value = 0.0;
             calcerr = CT_OK;
-            for(tf = NULL;tf = GetRangeCells(t,tf);r1.r_Value += tf-&gt;tf_Value);
+            for (tf = NULL; (tf = GetRangeCells(t, tf)) != 0; r1.r_Value += tf-&gt;tf_Value);
             rc = calcerr;
             r-&gt;r_Value = r1.r_Value;
             r-&gt;r_Type = RT_VALUE;
@@ -1040,6 +1047,7 @@
                     case OP_EQLESS: r-&gt;r_Value = r1.r_Value &lt;= r2.r_Value;    break;
                     case OP_EQUAL: r-&gt;r_Value = r1.r_Value == r2.r_Value;     break;
                     case OP_NOTEQUAL: r-&gt;r_Value = r1.r_Value != r2.r_Value;  break;
+                    default: break;
                 }
             }
             else if (r1.r_Type &amp; RT_TEXT &amp;&amp; r2.r_Type &amp; RT_TEXT)
@@ -1054,6 +1062,7 @@
                     case OP_EQLESS: r-&gt;r_Value = diff &lt;= 0;    break;
                     case OP_EQUAL: r-&gt;r_Value = diff == 0;     break;
                     case OP_NOTEQUAL: r-&gt;r_Value = diff != 0;  break;
+                    default: break;
                 }
             }
             else
@@ -1104,6 +1113,8 @@
             else
                 rc = CTERR_TYPE;
             break;
+		default:
+			break;
     }
     FreeString(r1.r_Text);  FreeString(r2.r_Text);
     return rc;
@@ -1172,7 +1183,7 @@
 {
     struct Name *cnm;
 
-    if (cnm = AllocPooled(pool,sizeof(struct Name)))
+    if ((cnm = AllocPooled(pool, sizeof(struct Name))) != 0)
     {
         CopyMem(nm,cnm,sizeof(struct Name));
         cnm-&gt;nm_Node.ln_Name = AllocString(nm-&gt;nm_Node.ln_Name);
@@ -1266,11 +1277,11 @@
 
 
 struct Name *
-AddName(struct MinList *list, STRPTR name, STRPTR content, BYTE type, struct Page *page)
+AddName(struct MinList *list, CONST_STRPTR name, STRPTR content, BYTE type, struct Page *page)
 {
     struct Name *nm;
 
-    if (nm = AllocPooled(pool,sizeof(struct Name)))
+    if ((nm = AllocPooled(pool, sizeof(struct Name))) != 0)
     {
         nm-&gt;nm_Node.ln_Name = AllocString(name);
         nm-&gt;nm_Node.ln_Type = type &amp; (~NMT_UNDEFINED);
@@ -1289,7 +1300,7 @@
                 UpdateName(nm);
             }
         }
-        AddTail(list, nm);
+        MyAddTail(list, nm);
 
         if ((nm-&gt;nm_Node.ln_Type &amp; NMT_DETACHED) == 0)
             AssignUnresolvedReferencesForName(page, nm);
@@ -1317,7 +1328,7 @@
     if (!fv)
         return NULL;
 
-    if (cfv = AllocPooled(pool,sizeof(struct FormatVorlage)))
+    if ((cfv = AllocPooled(pool, sizeof(struct FormatVorlage))) != 0)
     {
         CopyMem(fv,cfv,sizeof(struct FormatVorlage));
         cfv-&gt;fv_Node.ln_Name = AllocString(fv-&gt;fv_Node.ln_Name);
@@ -1397,7 +1408,7 @@
     struct FormatVorlage *fv;
     double value = 0.0;
 
-	if (fv = AllocPooled(pool, sizeof(struct FormatVorlage)))
+	if ((fv = AllocPooled(pool, sizeof(struct FormatVorlage))) != 0)
     {
         fv-&gt;fv_Node.ln_Name = AllocString(t);
         fv-&gt;fv_Node.ln_Pri = pri;
@@ -1419,7 +1430,7 @@
 		fv-&gt;fv_Preview = AllocString(FitValueInFormat(value, fv, NULL, 0, 0));
         fv-&gt;fv_Alignment = align == -1 ? TFA_RIGHT : align;
         fv-&gt;fv_NegativePen = pen;
-		AddTail(list, fv);
+		MyAddTail(list, fv);
     }
     return fv;
 }
@@ -1945,7 +1956,7 @@
 
 	index = 0;  zahl = 0.0;  sec = 0.0;  hour = 0;  m = 1;  day = 1;  year = 1;
 
-	while (type = GetFVType(fv, &amp;formatIndex))
+	while ((type = GetFVType(fv, &amp;formatIndex)) != 0)
     {
 		// ignore spaces
 		while (t[index] == ' ')
@@ -1960,7 +1971,7 @@
 				if (length != 0 &amp;&amp; !(length == 1 &amp;&amp; (t[index] == '-' || t[index] == '+')))
                 {
 					index += length;
-					if (length = nachkommastellen(t + index, &amp;zahl))
+					if ((length = nachkommastellen(t + index, &amp;zahl)) != 0)
 						index += length;
                 }
                 else
@@ -1972,7 +1983,7 @@
 			{
 				bool found = false;
 				int32 length;
-				char *s;
+				const char *s;
 
 				// iterate over the current locale
 				for (m = 0; m &lt; 12; m++)
@@ -2122,7 +2133,7 @@
                     case FVT_SSEC:
                     case FVT_SEC:
 						sec = longValue;
-						if (length = nachkommastellen(t + index, &amp;sec))
+						if ((length = nachkommastellen(t + index, &amp;sec)) != 0)
 							index += length;
                         break;
                     case FVT_SYEAR:
@@ -2176,6 +2187,7 @@
 			day += mday[m - 1];
             if (m &gt; 2 &amp;&amp; !(year % 4) &amp;&amp; (year % 100 || !(year % 400)))
                 day++;
+			// FIXME: GCC warning: operation on 'year' may be undefined
 			m = (long)--year * 365 + year / 4 - year / 100 + year / 400;
 			*_value = (double)(day + m);
             break;
@@ -2265,7 +2277,7 @@
         tf-&gt;tf_Type = TFT_VALUE;
 		if (tf_format &amp;&amp; (!tf-&gt;tf_Format || !FindLinkName(&amp;mp-&gt;mp_CalcFormats, tf-&gt;tf_Format)))
         {
-			if (fv = (struct FormatVorlage *)FindLinkName(&amp;mp-&gt;mp_CalcFormats, tf_format))
+			if ((fv = (struct FormatVorlage *)FindLinkName(&amp;mp-&gt;mp_CalcFormats, tf_format)) != 0)
             {
                 FreeString(tf-&gt;tf_Format);
                 tf-&gt;tf_Format = AllocString(tf_format);
@@ -2282,7 +2294,7 @@
                     STRPTR t;
                     long   i;
 
-					if (t = AllocString(tf_format))
+					if ((t = AllocString(tf_format)) != 0)
                     {
                         for(i = 0;*(t+i) &amp;&amp; !(*(t+i) == '#' &amp;&amp; tolower(*(t+i+1)) == 'y');i++);
                         if (*(t+ ++i) == 'y')
@@ -2298,7 +2310,7 @@
 			tf-&gt;tf_Text = AllocString(FitValueInFormat(tf-&gt;tf_Value, NULL, tf-&gt;tf_Format, tf-&gt;tf_Komma,
 								tf-&gt;tf_Flags &amp; (TFF_SEPARATE | TFF_NEGPARENTHESES)));
 
-			if (fv = (struct FormatVorlage *)FindLinkName(&amp;mp-&gt;mp_CalcFormats, tf-&gt;tf_Format))
+			if ((fv = (struct FormatVorlage *)FindLinkName(&amp;mp-&gt;mp_CalcFormats, tf-&gt;tf_Format)) != 0)
             {
                 if (tf-&gt;tf_Alignment &amp; TFA_VIRGIN)
                     tf-&gt;tf_Alignment = (tf-&gt;tf_Alignment &amp; TFA_VCENTER) | fv-&gt;fv_Alignment | TFA_VIRGIN;
@@ -2484,14 +2496,14 @@
     char   zahl[32];
     STRPTR s;
 
-    if (k = AllocPooled(pool,sizeof(struct Term)))
+    if ((k = AllocPooled(pool,sizeof(struct Term))) != 0)
     {
         s = *t;
         while(*++s == '.' || *s == ',' || IsAlNum(loc,*s))
             if (*s == ',') *s = '.';
         if (isdigit(**t))
         {
-            stccpy(zahl,*t,(long)(s-*t)+1);
+            stccpy(zahl, *t, (long)((char *)s - *t) + 1);
             k-&gt;t_Value = strtod(zahl,NULL);
             k-&gt;t_Op = OP_VALUE;
             k-&gt;t_Pri = PRI_TOP;
@@ -2530,7 +2542,7 @@
 {
     struct Term *k;
 
-    if (k = AllocPooled(pool,sizeof(struct Term)))
+    if ((k = AllocPooled(pool, sizeof(struct Term))) != 0)
     {
         k-&gt;t_Op = OP_NAME;
         k-&gt;t_Pri = PRI_TOP;
@@ -2582,7 +2594,7 @@
     struct Term *k;
     long   abs;
 
-    if (k = AllocPooled(pool,sizeof(struct Term)))
+    if ((k = AllocPooled(pool, sizeof(struct Term))) != 0)
     {
         abs = String2Coord(t,&amp;k-&gt;t_Col,&amp;k-&gt;t_Row);
         k-&gt;t_Op = OP_CELL;
@@ -2610,14 +2622,14 @@
     STRPTR buff;
 	long   i, j, size;
 
-    if (buff = AllocPooled(pool,size = strlen(t)+1))
+    if ((buff = AllocPooled(pool,size = strlen(t)+1)) != 0)
     {
-        if (k = AllocPooled(pool,sizeof(struct Term)))
+        if ((k = AllocPooled(pool, sizeof(struct Term))) != 0)
         {
             k-&gt;t_Op = OP_FUNC;
             f = FindFunction(name,k);
 
-            NewList((struct List *)&amp;k-&gt;t_Args);
+            MyNewList(&amp;k-&gt;t_Args);
             strcpy(buff, t);
             for (i = 1,j = 0;i &amp;&amp; *t;t++,j++)
             {
@@ -2636,14 +2648,14 @@
                 APTR stack;
                 ULONG size = 1024;
 
-                if (stack = AllocPooled(pool,size))
+                if ((stack = AllocPooled(pool, size)) != 0)
                 {
                     for(i = 0;i &lt; j;i += strlen(buff+i)+1)
                     {
-                        if (fa = AllocPooled(pool,sizeof(struct FuncArg)))
+                        if ((fa = AllocPooled(pool, sizeof(struct FuncArg))) != 0)
                         {
                             fa-&gt;fa_Root = createTree(buff+i,&amp;stack,&amp;size);
-                            AddTail((struct List *)&amp;k-&gt;t_Args,(struct Node *)fa);
+                            MyAddTail(&amp;k-&gt;t_Args, fa);
                         }
                     }
                     if ((calcerr = CheckFuncArgs(f,&amp;k-&gt;t_Args)) == CTERR_ARGS)
@@ -2664,7 +2676,7 @@
 {
     struct Term *t;
 
-    if (t = AllocPooled(pool, sizeof(struct Term)))
+    if ((t = AllocPooled(pool, sizeof(struct Term))) != 0)

[... truncated: 16781 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000016.html">[Ignition-commits] r14 - in trunk: docs misc misc/Masons Icons rexx
</A></li>
	<LI>Next message: <A HREF="000025.html">[Ignition-commits] r15 - in trunk: . distribution distribution/full/misc help/deutsch help/english libs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24">[ date ]</a>
              <a href="thread.html#24">[ thread ]</a>
              <a href="subject.html#24">[ subject ]</a>
              <a href="author.html#24">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/ignition-commits">More information about the Ignition-commits
mailing list</a><br>
</body></html>
